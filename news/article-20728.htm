<!DOCTYPE html>
<html lang="zh-CN">


<head>
        <link rel="canonical" href="https://todayclashnode.github.io/news/article-20728.htm" />
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>FreeRTOS实时操作系统队列的API函数讲解_操作系统</title>
        <meta name="description" content="目录  前言 1.获取队列入队信息数目  1.1函数描述 1.2参数描述  2.获取队列的空闲数目  2.1函数描述 2.2参数描述  3.删除队列  3.1函数描述 3.2参数描述  4.复位队列 " />
        <link rel="icon" href="__ADDON__/img/todayclashnode/favicon.ico" type="image/x-icon"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="all,follow">
    <!-- Bootstrap CSS-->
    <link rel="stylesheet" href="__ADDON__/js/frontend/todayclashnode/bootstrap/css/bootstrap.min.css">
    <!-- Font Awesome CSS-->
    <link rel="stylesheet" href="__ADDON__/js/frontend/todayclashnode/font-awesome/css/font-awesome.min.css">
    <!-- Google fonts - Poppins-->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Poppins:300,400,600">
    <!-- Lightbox-->
    <link rel="stylesheet" href="__ADDON__/js/frontend/todayclashnode/lightbox2/css/lightbox.css">
    <link rel="stylesheet" href="/assets/website/css/todayclashnode/fontastic.css">
    <!-- theme stylesheet-->
    <link rel="stylesheet" href="/assets/website/css/todayclashnode/style.default.css" id="theme-stylesheet">
    <!-- Custom stylesheet - for your changes-->
    <link rel="stylesheet" href="/assets/website/css/todayclashnode/custom.css">
    <!-- Tweaks for older IEs-->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
        <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script><![endif]-->
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-PB8VLG2G25"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-PB8VLG2G25');
</script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3332997411212854"
     crossorigin="anonymous"></script>
</head>

<body data-page="detail">
        <!-- navbar-->
    <header class="header">
        <nav class="navbar navbar-expand-lg fixed-top">
            <div class="container">
                                <a href="/" class="navbar-brand">
                    Today ClashNode
                </a>
                
                <button type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation" class="navbar-toggler navbar-toggler-right">Menu<i class="fa fa-bars ml-2"></i></button>
                <div id="navbarSupportedContent" class="collapse navbar-collapse">
                    <ul class="navbar-nav ml-auto">
                                                <!-- Link-->
                        <li class="nav-item"> <a href="/" class="nav-link">首页</a></li>
                                                <!-- Link-->
                        <li class="nav-item"> <a href="/free-nodes/" class="nav-link">免费节点</a></li>
                                                <!-- Link-->
                        <li class="nav-item"> <a href="/paid-subscribe/" class="nav-link">推荐机场</a></li>
                                                <!-- Link-->
                        <li class="nav-item"> <a href="/news/" class="nav-link">新闻资讯</a></li>
                                                <!-- Link-->
                        <li class="nav-item"> <a href="#" class="nav-link">关于</a></li>
                        <!-- Link-->
                        <li class="nav-item"> <a href="#" class="nav-link">联系</a></li>
                    </ul>
                </div>
            </div>
        </nav>
    </header>

    <!-- Hero Section-->
    <section class="hero">
        <div class="container text-center">
            <h1>FreeRTOS实时操作系统队列的API函数讲解_操作系统</h1>
            <nav aria-label="breadcrumb" class="d-flex justify-content-center">
                <ol class="breadcrumb">
                    <li class="breadcrumb-item"><a href="/" class="animsition-link">首页</a></li>
                    <li class="breadcrumb-item"><a href="/news/" class="animsition-link">新闻资讯</a></li>
                    <li aria-current="page" class="breadcrumb-item active">正文</li>
                </ol>
            </nav>
        </div>
    </section>
    <section>
        <div class="container">
            <div class="row" id="list">
                <div class="col-md-9">
                                          				  				  				<div id="navCategory"> <h5 class="catalogue">目录</h5> <ul class="first_class_ul"> <li><a href="#_label0" rel="nofollow">前言</a></li> <li><a href="#_label1" rel="nofollow">1.获取队列入队信息数目</a></li> <ul class="second_class_ul"> <li><a href="#_lab2_1_0" rel="nofollow">1.1函数描述</a></li> <li><a href="#_lab2_1_1" rel="nofollow">1.2参数描述</a></li> </ul> <li><a href="#_label2" rel="nofollow">2.获取队列的空闲数目</a></li> <ul class="second_class_ul"> <li><a href="#_lab2_2_2" rel="nofollow">2.1函数描述</a></li> <li><a href="#_lab2_2_3" rel="nofollow">2.2参数描述</a></li> </ul> <li><a href="#_label3" rel="nofollow">3.删除队列</a></li> <ul class="second_class_ul"> <li><a href="#_lab2_3_4" rel="nofollow">3.1函数描述</a></li> <li><a href="#_lab2_3_5" rel="nofollow">3.2参数描述</a></li> </ul> <li><a href="#_label4" rel="nofollow">4.复位队列</a></li> <ul class="second_class_ul"> <li><a href="#_lab2_4_6" rel="nofollow">4.1函数描述</a></li> <li><a href="#_lab2_4_7" rel="nofollow">4.2参数描述</a></li> <li><a href="#_lab2_4_8" rel="nofollow">4.3返回值</a></li> </ul> <li><a href="#_label5" rel="nofollow">5.创建队列</a></li> <ul class="second_class_ul"> <li><a href="#_lab2_5_9" rel="nofollow">5.1函数描述</a></li> <li><a href="#_lab2_5_10" rel="nofollow">5.2参数描述</a></li> <li><a href="#_lab2_5_11" rel="nofollow">5.3返回值</a></li> <li><a href="#_lab2_5_12" rel="nofollow">5.4用法举例</a></li> </ul> <li><a href="#_label6" rel="nofollow">6.向队列投递队列项</a></li> <ul class="second_class_ul"> <li><a href="#_lab2_6_13" rel="nofollow">6.1 函数描述</a></li> <li><a href="#_lab2_6_14" rel="nofollow">6.2参数描述</a></li> <li><a href="#_lab2_6_15" rel="nofollow">6.3返回值</a></li> <li><a href="#_lab2_6_16" rel="nofollow">6.4用法举例</a></li> </ul> <li><a href="#_label7" rel="nofollow">7.向队列投递队列项（带中断保护）</a></li> <ul class="second_class_ul"> <li><a href="#_lab2_7_17" rel="nofollow">7.1函数描述</a></li> <li><a href="#_lab2_7_18" rel="nofollow">7.2参数描述</a></li> <li><a href="#_lab2_7_19" rel="nofollow">7.3返回值</a></li> <li><a href="#_lab2_7_20" rel="nofollow">7.4用法举例</a></li> </ul> <li><a href="#_label8" rel="nofollow">8.向队列尾部投递队列项</a></li> <ul class="second_class_ul"> <li><a href="#_lab2_8_21" rel="nofollow">8.1函数描述</a></li> <li><a href="#_lab2_8_22" rel="nofollow">8.2参数描述</a></li> <li><a href="#_lab2_8_23" rel="nofollow">8.3返回值</a></li> <li><a href="#_lab2_8_24" rel="nofollow">8.4用法举例</a></li> </ul> <li><a href="#_label9" rel="nofollow">9.向队列尾部投递队列项（带中断保护）</a></li> <ul class="second_class_ul"> <li><a href="#_lab2_9_25" rel="nofollow">9.1函数描述</a></li> <li><a href="#_lab2_9_26" rel="nofollow">9.2参数描述</a></li> <li><a href="#_lab2_9_27" rel="nofollow">9.3返回值</a></li> <li><a href="#_lab2_9_28" rel="nofollow">9.4用法举例</a></li> </ul> <li><a href="#_label10" rel="nofollow">10.向队列首部投递队列项</a></li> <ul class="second_class_ul"> <li><a href="#_lab2_10_29" rel="nofollow">10.1函数描述</a></li> <li><a href="#_lab2_10_30" rel="nofollow">10.2参数描述</a></li> <li><a href="#_lab2_10_31" rel="nofollow">10.3返回值</a></li> </ul> <li><a href="#_label11" rel="nofollow">11.向队列首部投递队列项（带中断保护）</a></li> <ul class="second_class_ul"> <li><a href="#_lab2_11_32" rel="nofollow">11.1函数描述</a></li> <li><a href="#_lab2_11_33" rel="nofollow">11.2参数描述</a></li> <li><a href="#_lab2_11_34" rel="nofollow">11.3返回值</a></li> </ul> <li><a href="#_label12" rel="nofollow">12.读取并移除队列项</a></li> <ul class="second_class_ul"> <li><a href="#_lab2_12_35" rel="nofollow">12.1函数描述</a></li> <li><a href="#_lab2_12_36" rel="nofollow">12.2参数描述</a></li> <li><a href="#_lab2_12_37" rel="nofollow">12.3返回值</a></li> <li><a href="#_lab2_12_38" rel="nofollow">12.4用法举例</a></li> </ul> <li><a href="#_label13" rel="nofollow">13读取并移除队列项（带中断保护）</a></li> <ul class="second_class_ul"> <li><a href="#_lab2_13_39" rel="nofollow">13.1函数描述</a></li> <li><a href="#_lab2_13_40" rel="nofollow">13.2参数描述</a></li> <li><a href="#_lab2_13_41" rel="nofollow">13.3返回值</a></li> <li><a href="#_lab2_13_42" rel="nofollow">13.4用法举例</a></li> </ul> <li><a href="#_label14" rel="nofollow">14.读取但不移除队列项</a></li> <ul class="second_class_ul"> <li><a href="#_lab2_14_43" rel="nofollow">14.1函数描述</a></li> <li><a href="#_lab2_14_44" rel="nofollow">14.2参数描述</a></li> <li><a href="#_lab2_14_45" rel="nofollow">14.3返回值</a></li> <li><a href="#_lab2_14_46" rel="nofollow">14.4用法举例</a></li> </ul> <li><a href="#_label15" rel="nofollow">15.读取但不移除队列项（带中断保护）</a></li> <ul class="second_class_ul"> <li><a href="#_lab2_15_47" rel="nofollow">15.1函数描述</a></li> <li><a href="#_lab2_15_48" rel="nofollow">15.2参数描述</a></li> <li><a href="#_lab2_15_49" rel="nofollow">15.3返回值</a></li> </ul> <li><a href="#_label16" rel="nofollow">16.队列注册</a></li> <ul class="second_class_ul"> <li><a href="#_lab2_16_50" rel="nofollow">16.1函数描述</a></li> <li><a href="#_lab2_16_51" rel="nofollow">16.2参数描述</a></li> <li><a href="#_lab2_16_52" rel="nofollow">16.3用法举例</a></li> </ul> <li><a href="#_label17" rel="nofollow">17.解除注册</a></li> <ul class="second_class_ul"> <li><a href="#_lab2_17_53" rel="nofollow">17.1函数描述</a></li> <li><a href="#_lab2_17_54" rel="nofollow">17.2参数描述</a></li> </ul> <li><a href="#_label18" rel="nofollow">18.查询队列是否为空（仅用于中断服务程序）</a></li> <ul class="second_class_ul"> <li><a href="#_lab2_18_55" rel="nofollow">18.1函数描述</a></li> <li><a href="#_lab2_18_56" rel="nofollow">18.2参数描述</a></li> <li><a href="#_lab2_18_57" rel="nofollow">18.3返回值</a></li> </ul> <li><a href="#_label19" rel="nofollow">19.查询队列是否满（仅用于中断服务程序）</a></li> <ul class="second_class_ul"> <li><a href="#_lab2_19_58" rel="nofollow">19.1函数描述</a></li> <li><a href="#_lab2_19_59" rel="nofollow">19.2参数描述</a></li> <li><a href="#_lab2_19_60" rel="nofollow">19.3返回值</a></li> </ul> <li><a href="#_label20" rel="nofollow">20.向队列尾部覆盖式投递队列项</a></li> <ul class="second_class_ul"> <li><a href="#_lab2_20_61" rel="nofollow">20.1函数描述</a></li> <li><a href="#_lab2_20_62" rel="nofollow">20.2参数描述</a></li> <li><a href="#_lab2_20_63" rel="nofollow">20.3返回值</a></li> <li><a href="#_lab2_20_64" rel="nofollow">20.4用法举例</a></li> </ul> <li><a href="#_label21" rel="nofollow">21向队列尾部覆盖式投递队列项（带中断保护）</a></li> <ul class="second_class_ul"> <li><a href="#_lab2_21_65" rel="nofollow">21.1函数描述</a></li> <li><a href="#_lab2_21_66" rel="nofollow">21.2参数描述</a></li> <li><a href="#_lab2_21_67" rel="nofollow">21.3返回值</a></li> </ul> </ul> </div> <p class="maodian"><a name="_label0" rel="nofollow"></a></p> <h2>前言</h2> <p>FreeRTOS为操作队列提供了非常丰富的API函数，包括队列的创建、删除，灵活的入队和出队方式、带中断保护的入队和出队等等。下面就来详细讲述这些API函数。</p> <p class="maodian"><a name="_label1" rel="nofollow"></a></p> <h2>1.获取队列入队信息数目</h2> <p class="maodian"><a name="_lab2_1_0" rel="nofollow"></a></p> <h3>1.1函数描述</h3> <blockquote> <p>UBaseType_t uxQueueMessagesWaiting( QueueHandle_t xQueue );</p> </blockquote> <p>返回队列中存储的信息数目。具有中断保护的版本为uxQueueMessagesWaitingFromISR()，原型为：UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )。</p> <p class="maodian"><a name="_lab2_1_1" rel="nofollow"></a></p> <h3>1.2参数描述</h3> <p>xQueue：队列句柄</p> <p class="maodian"><a name="_label2" rel="nofollow"></a></p> <h2>2.获取队列的空闲数目</h2> <p class="maodian"><a name="_lab2_2_2" rel="nofollow"></a></p> <h3>2.1函数描述</h3> <blockquote> <p>UBaseType_t uxQueueSpacesAvailable( QueueHandle_t xQueue );</p> </blockquote> <p>返回队列的空闲数目。</p> <p class="maodian"><a name="_lab2_2_3" rel="nofollow"></a></p> <h3>2.2参数描述</h3> <p>xQueue：队列句柄</p> <p class="maodian"><a name="_label3" rel="nofollow"></a></p> <h2>3.删除队列</h2> <p class="maodian"><a name="_lab2_3_4" rel="nofollow"></a></p> <h3>3.1函数描述</h3> <blockquote> <p>void vQueueDelete( QueueHandle_t xQueue );</p> </blockquote> <p>删除队列并释放所有分配给队列的内存。</p> <p class="maodian"><a name="_lab2_3_5" rel="nofollow"></a></p> <h3>3.2参数描述</h3> <p>xQueue：队列句柄</p> <p class="maodian"><a name="_label4" rel="nofollow"></a></p> <h2>4.复位队列</h2> <p class="maodian"><a name="_lab2_4_6" rel="nofollow"></a></p> <h3>4.1函数描述</h3> <blockquote> <p>BaseType_t xQueueReset( QueueHandle_t xQueue );</p> </blockquote> <p>将队列复位到初始状态。</p> <p class="maodian"><a name="_lab2_4_7" rel="nofollow"></a></p> <h3>4.2参数描述</h3> <p>xQueue：队列句柄</p> <p class="maodian"><a name="_lab2_4_8" rel="nofollow"></a></p> <h3>4.3返回值</h3> <p>FreeRTOSV7.2.0以及以后的版本总是返回pdPASS。</p> <p class="maodian"><a name="_label5" rel="nofollow"></a></p> <h2>5.创建队列</h2> <p class="maodian"><a name="_lab2_5_9" rel="nofollow"></a></p> <h3>5.1函数描述</h3> <blockquote> <p>QueueHandle_t xQueueCreate (UBaseType_t uxQueueLength, UBaseType_t uxItemSize);</p> </blockquote> <p>创建新队列。为新队列分配指定的存储空间并返回队列句柄。</p> <p class="maodian"><a name="_lab2_5_10" rel="nofollow"></a></p> <h3>5.2参数描述</h3> <p><code>usQueueLength</code>：队列项数目</p> <p><code>uxItemSize</code>：每个队列项大小，单位是字节。队列项通过拷贝入队而不是通过引用入队，因此需要队列项的大小。每个队列项的大小必须相同。</p> <p class="maodian"><a name="_lab2_5_11" rel="nofollow"></a></p> <h3>5.3返回值</h3> <p>成功创建队列返回队列句柄，否自返回0。</p> <p class="maodian"><a name="_lab2_5_12" rel="nofollow"></a></p> <h3>5.4用法举例</h3> <div class="ay1code"> <pre class="brush:cpp;"> struct AMessage   {       portCHAR ucMessageID;       portCHAR ucData[ 20 ];   };   void vATask( void*pvParameters )   {       xQueueHandle xQueue1, xQueue2;       // 创建一个队列，队列能包含10个unsigned long类型的值。       xQueue1 = xQueueCreate( 10, sizeof( unsigned portLONG ));       if( xQueue1 ==0 )       {           // 队列创建失败，不可以使用       }       // 创建一个队列，队列能包含10个 Amessage结构体指针类型的值。       // 这样可以通过传递指针变量来包含大量数据。       xQueue2 =xQueueCreate( 10, sizeof( struct AMessage * ) );       if( xQueue2 ==0 )       {           // 队列创建失败，不可以使用       }       // ... 任务的其它代码.   }</pre> </div> <p class="maodian"><a name="_label6" rel="nofollow"></a></p> <h2>6.向队列投递队列项</h2> <p class="maodian"><a name="_lab2_6_13" rel="nofollow"></a></p> <h3>6.1 函数描述</h3> <blockquote> <p>BaseType_txQueueSend(QueueHandle_t xQueue, const void * pvItemToQueue, TickType_t xTicksToWait );</p> </blockquote> <p>其实是一个宏，真正被调用的函数是xQueueGenericSend()。定义这个宏是为了向后兼容那些不包含函数xQueueSendToFront()和xQueueSendToBack()宏的FreeRTOS版本。它与xQueueSendToBack()等同。</p> <p>这个宏向队列尾部投递一个队列项。项目以拷贝的形式入队，而不是引用形式入队。绝不可以在中断服务例程中调用这个宏，使用带有中断保护的版本xQueueSendFromISR()来完成相同的功能。</p> <p class="maodian"><a name="_lab2_6_14" rel="nofollow"></a></p> <h3>6.2参数描述</h3> <p><code>xQueue</code>：队列句柄。</p> <p><code>pvItemToQueue</code>：指针，指向要入队的项目。要保存到队列中的项目字节数在队列创建时就已确定。因此要从指针pvItemToQueue指向的区域拷贝到队列存储区域的字节数，也已确定。</p> <p><code>xTicksToWait</code>：如果队列满，任务等待队列空闲的最大时间。如果队列满并且xTicksToWait被设置成0，函数立刻返回。时间单位为系统节拍时钟周期，因此宏portTICK_PERIOD_MS可以用来辅助计算真实延时值。如果INCLUDE_vTaskSuspend设置成1，并且指定延时为portMAX_DELAY将引起任务无限阻塞（没有超时）。</p> <p class="maodian"><a name="_lab2_6_15" rel="nofollow"></a></p> <h3>6.3返回值</h3> <p>队列项入队成功返回pdTRUE，否则返回errQUEUE_FULL。</p> <p class="maodian"><a name="_lab2_6_16" rel="nofollow"></a></p> <h3>6.4用法举例</h3> <div class="ay1code"> <pre class="brush:cpp;">struct AMessage   {        portCHAR ucMessageID;        portCHAR ucData[ 20 ];   }xMessage;   unsigned portLONG ulVar = 10UL;   void vATask( void *pvParameters )   {       xQueueHandle xQueue1, xQueue2;       struct AMessage *pxMessage;       /*创建一个队列，队列能包含10个unsigned long类型的值。*/       xQueue1 = xQueueCreate( 10, sizeof( unsigned portLONG ) );       /* 创建一个队列，队列能包含10个 Amessage结构体指针类型的值。         这样可以通过传递指针变量来包含大量数据。*/       xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );       // ...       if( xQueue1 != 0 )       {            /*1个unsigned long型数据入队.如果需要等待队列空间变的有效，           会最多等待10个系统节拍周期*/            if( xQueueSend( xQueue1, ( void * ) &amp;ulVar, ( portTickType ) 10 ) !=pdPASS )            {                 /*消息入队失败*/            }      }      if( xQueue2 != 0 )      {           /* 发送一个指向结构体Amessage的对象，如果队列满也不等待 */           pxMessage = &amp; xMessage;           xQueueSend( xQueue2, ( void * ) &amp;pxMessage, ( portTickType ) 0 );      }           //... 任务其余代码.   }</pre> </div> <p class="maodian"><a name="_label7" rel="nofollow"></a></p> <h2>7.向队列投递队列项（带中断保护）</h2> <p class="maodian"><a name="_lab2_7_17" rel="nofollow"></a></p> <h3>7.1函数描述</h3> <div class="ay1code"> <pre class="brush:cpp;">     BaseType_t xQueueSendFromISR (QueueHandle_t xQueue,                 const void *pvItemToQueue,  BaseType_t *pxHigherPriorityTaskWoken);</pre> </div> <p>其实是一个宏，真正被调用的函数是xQueueGenericSendFromISR()。这个宏是xQueueSend()的中断保护版本，用于中断服务程序，等价于xQueueSendToBackFromISR()。</p> <p>在中断服务例程中向队列尾部投递一个队列项。</p> <p class="maodian"><a name="_lab2_7_18" rel="nofollow"></a></p> <h3>7.2参数描述</h3> <p><code>xQueue</code>：队列句柄。</p> <p><code>pvItemToQueue</code>：指针，指向要入队的项目。要保存到队列中的项目字节数在队列创建时就已确定。因此要从指针pvItemToQueue指向的区域拷贝到队列存储区域的字节数，也已确定。</p> <p><code>pxHigherPriorityTaskWoken</code>：如果入队导致一个任务解锁，并且解锁的任务优先级高于当前运行的任务，则该函数将*pxHigherPriorityTaskWoken设置成pdTRUE。如果xQueueSendFromISR()设置这个值为pdTRUE，则中断退出前需要一次上下文切换。</p> <p>从FreeRTOS V7.3.0起，pxHigherPriorityTaskWoken称为一个可选参数，并可以设置为NULL。</p> <p class="maodian"><a name="_lab2_7_19" rel="nofollow"></a></p> <h3>7.3返回值</h3> <p>列项入队成功返回pdTRUE，否则返回errQUEUE_FULL。</p> <p class="maodian"><a name="_lab2_7_20" rel="nofollow"></a></p> <h3>7.4用法举例</h3> <div class="ay1code"> <pre class="brush:cpp;">void vBufferISR( void )  {      portCHARcIn;      portBASE_TYPE xHigherPriorityTaskWoken;      /* 初始化，没有唤醒任务*/      xHigherPriorityTaskWoken = pdFALSE;         /* 直到缓冲区为空 */      do      {          /* 从缓冲区获得一个字节数据 */          cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );                                                                /* 投递这个数据 */          xQueueSendFromISR( xRxQueue, &amp;cIn, &amp;xHigherPriorityTaskWoken );      }while( portINPUT_BYTE( BUFFER_COUNT ) );      /* 这里缓冲区已空，如果需要进行一个上下文切换*/      /*根据不同移植平台，这个函数也不同*/      portYIELD_FROM_ISR(xHigherPriorityTaskWoken);  }</pre> </div> <p class="maodian"><a name="_label8" rel="nofollow"></a></p> <h2>8.向队列尾部投递队列项</h2> <p class="maodian"><a name="_lab2_8_21" rel="nofollow"></a></p> <h3>8.1函数描述</h3> <div class="ay1code"> <pre class="brush:cpp;">      BaseType_t xQueueSendToBack(QueueHandle_t xQueue,                           const void * pvItemToQueue, TickType_t xTicksToWait );</pre> </div> <p>其实是一个宏，真正被调用的函数是xQueueGenericSend()。这个宏等价于xQueueSend()。</p> <p>向队列尾投递一个队列项。绝不可以在中断中调用这个宏，可以使用带有中断保护的版本xQueueSendToBackFromISR ()来完成相同功能。</p> <p class="maodian"><a name="_lab2_8_22" rel="nofollow"></a></p> <h3>8.2参数描述</h3> <p>同xQueueSend()。</p> <p class="maodian"><a name="_lab2_8_23" rel="nofollow"></a></p> <h3>8.3返回值</h3> <p>同xQueueSend()。</p> <p class="maodian"><a name="_lab2_8_24" rel="nofollow"></a></p> <h3>8.4用法举例</h3> <p>同xQueueSend()。</p> <p class="maodian"><a name="_label9" rel="nofollow"></a></p> <h2>9.向队列尾部投递队列项（带中断保护）</h2> <p class="maodian"><a name="_lab2_9_25" rel="nofollow"></a></p> <h3>9.1函数描述</h3> <div class="ay1code"> <pre class="brush:cpp;">      BaseType_t xQueueSendToBackFromISR (QueueHandle_t xQueue,              const void *pvItemToQueue, BaseType_t *pxHigherPriorityTaskWoken );</pre> </div> <p>其实是一个宏，真正被调用的函数是xQueueGenericSendFromISR()。这个宏是xQueueSendToBack()的中断保护版本，用于中断服务程序，等价于xQueueSendFromISR()。</p> <p>在中断服务例程中向队列尾部投递一个队列项。</p> <p class="maodian"><a name="_lab2_9_26" rel="nofollow"></a></p> <h3>9.2参数描述</h3> <p>同QueueSendFromISR()。</p> <p class="maodian"><a name="_lab2_9_27" rel="nofollow"></a></p> <h3>9.3返回值</h3> <p>同QueueSendFromISR()。</p> <p class="maodian"><a name="_lab2_9_28" rel="nofollow"></a></p> <h3>9.4用法举例</h3> <p>同QueueSendFromISR()。</p> <p class="maodian"><a name="_label10" rel="nofollow"></a></p> <h2>10.向队列首部投递队列项</h2> <p class="maodian"><a name="_lab2_10_29" rel="nofollow"></a></p> <h3>10.1函数描述</h3> <div class="ay1code"> <pre class="brush:cpp;">      BaseType_t xQueueSendToFront(QueueHandle_t xQueue,                 const void * pvItemToQueue,TickType_t xTicksToWait);</pre> </div> <p>其实是一个宏，真正被调用的函数是xQueueGenericSend()。</p> <p>这个宏向队列首部投递一个队列项。绝不可以在中断服务例程中调用这个宏，可以使用带有中断保护的版本xQueueSendToFrontFromISR ()来完成相同功能。</p> <p class="maodian"><a name="_lab2_10_30" rel="nofollow"></a></p> <h3>10.2参数描述</h3> <p><code>xQueue</code>：队列句柄。</p> <p><code>pvItemToQueue</code>：指针，指向要入队的项目。要保存到队列中的项目字节数在队列创建时就已确定。因此要从指针pvItemToQueue指向的区域拷贝到队列存储区域的字节数，也已确定。</p> <p><code>xTicksToWait</code>：如果队列满，任务等待队列空闲的最大时间。如果队列满并且xTicksToWait被设置成0，函数立刻返回。时间单位为系统节拍时钟周期，因此宏portTICK_PERIOD_MS可以用来辅助计算真实延时值。如果INCLUDE_vTaskSuspend设置成1，并且指定延时为portMAX_DELAY将引起任务无限阻塞（没有超时）。</p> <p class="maodian"><a name="_lab2_10_31" rel="nofollow"></a></p> <h3>10.3返回值</h3> <p>队列项入队成功返回pdTRUE，否则返回errQUEUE_FULL。</p> <p class="maodian"><a name="_label11" rel="nofollow"></a></p> <h2>11.向队列首部投递队列项（带中断保护）</h2> <p class="maodian"><a name="_lab2_11_32" rel="nofollow"></a></p> <h3>11.1函数描述</h3> <div class="ay1code"> <pre class="brush:cpp;">      BaseType_t xQueueSendToFrontFromISR (QueueHandle_t xQueue,                const void *pvItemToQueue,BaseType_t *pxHigherPriorityTaskWoken);</pre> </div> <p>其实是一个宏，真正被调用的函数是xQueueGenericSendFromISR()。这个宏是xQueueSendToFront ()的中断保护版本，用于中断服务程序。</p> <p class="maodian"><a name="_lab2_11_33" rel="nofollow"></a></p> <h3>11.2参数描述</h3> <p><code>xQueue</code>：队列句柄。</p> <p><code>pvItemToQueue</code>：指针，指向要入队的项目。要保存到队列中的项目字节数在队列创建时就已确定。因此要从指针pvItemToQueue指向的区域拷贝到队列存储区域的字节数，也已确定。</p> <p><code>pxHigherPriorityTaskWoken</code>：如果入队导致一个任务解锁，并且解锁的任务优先级高于当前运行的任务，则该函数将*pxHigherPriorityTaskWoken设置成pdTRUE。如果xQueueSendFromISR()设置这个值为pdTRUE，则中断退出前需要一次上下文切换。从FreeRTOS V7.3.0起，pxHigherPriorityTaskWoken称为一个可选参数，并可以设置为NULL。</p> <p class="maodian"><a name="_lab2_11_34" rel="nofollow"></a></p> <h3>11.3返回值</h3> <p>列项入队成功返回pdTRUE，否则返回errQUEUE_FULL。</p> <p class="maodian"><a name="_label12" rel="nofollow"></a></p> <h2>12.读取并移除队列项</h2> <p class="maodian"><a name="_lab2_12_35" rel="nofollow"></a></p> <h3>12.1函数描述</h3> <div class="ay1code"> <pre class="brush:cpp;">      BaseType_t xQueueReceive(QueueHandle_t xQueue,                             void *pvBuffer,TickType_t xTicksToWait);</pre> </div> <p>其实是一个宏，真正被调用的函数是xQueueGenericReceive()。</p> <p>这个宏从队列中读取一个队列项并把该队列项从队列中删除。读取队列项是以拷贝的形式完成，而不是以引用的形式，因此必须提供足够大的缓冲区以便容纳队列项。参数pvBuffer指向这个缓冲区。</p> <p>绝不可以在中断服务例程中调用这个宏，可以使用使用带有中断保护的版本xQueueReceiveFromISR来完成相同功能。</p> <p class="maodian"><a name="_lab2_12_36" rel="nofollow"></a></p> <h3>12.2参数描述</h3> <p><code>pxQueue</code>：队列句柄。</p> <p><code>pvBuffer</code>：指向一个缓冲区，用于拷贝接收到的列表项。</p> <p><code>xTicksToWait</code>：要接收的项目队列为空时，允许任务最大阻塞时间。如果设置该参数为0，则表示即队列为空也立即返回。阻塞时间的单位是系统节拍周期，宏portTICK_RATE_MS可辅助计算真实阻塞时间。如果INCLUDE_vTaskSuspend设置成1，并且阻塞时间设置成portMAX_DELAY，将会引起任务无限阻塞（不会有超时）。</p> <p class="maodian"><a name="_lab2_12_37" rel="nofollow"></a></p> <h3>12.3返回值</h3> <p>成功接收到列表项返回pdTRUE，否则返回pdFALSE。</p> <p class="maodian"><a name="_lab2_12_38" rel="nofollow"></a></p> <h3>12.4用法举例</h3> <div class="ay1code"> <pre class="brush:cpp;">struct AMessage  {      portCHAR ucMessageID;      portCHAR ucData[ 20 ];  } xMessage;  xQueueHandle xQueue;  // 创建一个队列并投递一个值  void vATask( void *pvParameters )  {       struct AMessage *pxMessage;       // 创建一个队列，队列能包含10个 Amessage结构体指针类型的值。       // 这样可以通过传递指针变量来包含大量数据。       xQueue =xQueueCreate( 10, sizeof( struct AMessage * ) );       if( xQueue == 0)       {            // 创建队列失败      }      // ...      // 向队列发送一个指向结构体对象Amessage的指针，如果队列满不等待      pxMessage = &amp; xMessage;      xQueueSend(xQueue, ( void * ) &amp;pxMessage, ( portTickType ) 0 );      // ... 其它代码  }  // 该任务从队列中接收一个队列项  voidvADifferentTask( void *pvParameters )  {      struct AMessage *pxRxedMessage;         if( xQueue != 0)      {          // 从创建的队列中接收一个消息，如果消息无效，最多阻塞10个系统节拍周期          if(xQueueReceive( xQueue, &amp;( pxRxedMessage ), ( portTickType ) 10 ) )          {              // 现在pcRxedMessage 指向由vATask任务投递进来的结构体Amessage变量          }      }     // ... 其它代码   }</pre> </div> <p class="maodian"><a name="_label13" rel="nofollow"></a></p> <h2>13读取并移除队列项（带中断保护）</h2> <p class="maodian"><a name="_lab2_13_39" rel="nofollow"></a></p> <h3>13.1函数描述</h3> <div class="ay1code"> <pre class="brush:cpp;">      BaseType_t xQueueReceiveFromISR (QueueHandle_t xQueue,                void *pvBuffer, BaseType_t *pxHigherPriorityTaskWoken);</pre> </div> <p>从队列中读取一个队列项并把该队列项从队列中删除。功能与xQueueReceive()相同，用于中断服务函数。</p> <p class="maodian"><a name="_lab2_13_40" rel="nofollow"></a></p> <h3>13.2参数描述</h3> <p><code>pxQueue</code>：队列句柄。</p> <p><code>pvBuffer</code>：指向一个缓冲区，用于拷贝接收到的列表项。</p> <p><code>pxHigherPriorityTaskWoken</code>：如果入队导致一个任务解锁，并且解锁的任务优先级高于当前运行的任务，则该函数将*pxHigherPriorityTaskWoken设置成pdTRUE。如果xQueueSendFromISR()设置这个值为pdTRUE，则中断退出前需要一次上下文切换。从FreeRTOS V7.3.0起，pxHigherPriorityTaskWoken称为一个可选参数，并可以设置为NULL。</p> <p class="maodian"><a name="_lab2_13_41" rel="nofollow"></a></p> <h3>13.3返回值</h3> <p>成功接收到列表项返回pdTRUE，否则返回pdFALSE。</p> <p class="maodian"><a name="_lab2_13_42" rel="nofollow"></a></p> <h3>13.4用法举例</h3> <div class="ay1code"> <pre class="brush:cpp;">xQueueHandle xQueue;  /* 该函数创建一个队列并投递一些值 */  voidvAFunction( void *pvParameters )  {       portCHAR cValueToPost;       const portTickType xBlockTime = (portTickType )0xff;       /*创建一个队列，可以容纳10个portCHAR型变量 */       xQueue = xQueueCreate( 10, sizeof( portCHAR ) );       if( xQueue == 0 )       {            /* 队列创建失败 */       }      /*…... */      /* 投递一些字符，在ISR中使用。如果队列满，任务将会阻塞xBlockTime 个系统节拍周期 */      cValueToPost = 'a';      xQueueSend( xQueue, ( void * ) &amp;cValueToPost, xBlockTime );      cValueToPost = 'b';      xQueueSend( xQueue, ( void * ) &amp;cValueToPost, xBlockTime );      /*... 继续投递字符 ... 当队列满时，这个任务会阻塞*/      cValueToPost = 'c';      xQueueSend( xQueue, ( void * ) &amp;cValueToPost, xBlockTime );  }  /* ISR：输出从队列接收到的所有字符 */  voidvISR_Routine( void )  {       portBASE_TYPE xTaskWokenByReceive = pdFALSE;       portCHAR cRxedChar;       while( xQueueReceiveFromISR( xQueue, ( void *) &amp;cRxedChar, &amp;xTaskWokenByReceive) )      {         /* 接收到一个字符串，输出.*/         vOutputCharacter( cRxedChar );         /* 如果从队列移除一个字符串后唤醒了向此队列投递字符的任务，那么参数xTaskWokenByReceive将会设置成pdTRUE，这个循环无论重复多少次，仅会            有一个任务被唤醒。*/      }      /*这里缓冲区已空，如果需要进行一个上下文切换根据不同移植平台，这个函数也不同 */      portYIELD_FROM_ISR(xTaskWokenByReceive);  }</pre> </div> <p class="maodian"><a name="_label14" rel="nofollow"></a></p> <h2>14.读取但不移除队列项</h2> <p class="maodian"><a name="_lab2_14_43" rel="nofollow"></a></p> <h3>14.1函数描述</h3> <div class="ay1code"> <pre class="brush:cpp;">      BaseType_t xQueuePeek(QueueHandle_t xQueue,                void *pvBuffer, TickType_t xTicksToWait);</pre> </div> <p>其实是一个宏，真正被调用的函数是xQueueGenericReceive()。</p> <p>这个宏从队列中读取一个队列项，但不会把该队列项从队列中移除。这个宏绝不可以用在中断服务例程中，可以使用使用带有中断保护的版本xQueuePeekFromIS()来完成相同功能。</p> <p class="maodian"><a name="_lab2_14_44" rel="nofollow"></a></p> <h3>14.2参数描述</h3> <p>同xQueueReceive()。</p> <p class="maodian"><a name="_lab2_14_45" rel="nofollow"></a></p> <h3>14.3返回值</h3> <p>同xQueueReceive()。</p> <p class="maodian"><a name="_lab2_14_46" rel="nofollow"></a></p> <h3>14.4用法举例</h3> <p>同xQueueReceive()。</p> <p class="maodian"><a name="_label15" rel="nofollow"></a></p> <h2>15.读取但不移除队列项（带中断保护）</h2> <p class="maodian"><a name="_lab2_15_47" rel="nofollow"></a></p> <h3>15.1函数描述</h3> <blockquote> <p>BaseType_t xQueuePeekFromISR(QueueHandle_t xQueue, void *pvBuffer,);</p> </blockquote> <p>功能与xQueuePeek()相同，用于中断服务程序。</p> <p class="maodian"><a name="_lab2_15_48" rel="nofollow"></a></p> <h3>15.2参数描述</h3> <p>pxQueue：队列句柄。pvBuffer：指向一个缓冲区，用于拷贝接收到的列表项。</p> <p class="maodian"><a name="_lab2_15_49" rel="nofollow"></a></p> <h3>15.3返回值</h3> <p>成功接收到列表项返回pdTRUE，否则返回pdFALSE。</p> <p class="maodian"><a name="_label16" rel="nofollow"></a></p> <h2>16.队列注册</h2> <p class="maodian"><a name="_lab2_16_50" rel="nofollow"></a></p> <h3>16.1函数描述</h3> <blockquote> <p>void vQueueAddToRegistry(QueueHandle_t xQueue, char *pcQueueName,);</p> </blockquote> <p>为队列分配名字并进行注册。</p> <p class="maodian"><a name="_lab2_16_51" rel="nofollow"></a></p> <h3>16.2参数描述</h3> <p><code>xQueue</code>：队列句柄</p> <p><code>pcQueueName</code>：分配给队列的名字。这仅是一个有助于调试的字符串。队列注册仅存储指向队列名字符串的指针，因此这个字符串必须是静态的（全局变量活着存储在ROM/Flash中），不可以定义到堆栈中。</p> <p>队列注册有两个目的，这两个目的都是为了调试RTOS内核：</p> <p>它允许队列具有一个相关的文本名字，在GUI调试中可以容易的标识队列；包含调试器用于定位每一个已经注册的队列和信号量时所需的信息。</p> <p>队列注册仅用于调试器。</p> <p>宏configQUEUE_REGISTRY_SIZE定义了可以注册的队列和信号量的最大数量。仅当你想使用可视化调试内核时，才进行队列和信号量注册。</p> <p class="maodian"><a name="_lab2_16_52" rel="nofollow"></a></p> <h3>16.3用法举例</h3> <div class="ay1code"> <pre class="brush:cpp;">void vAFunction( void )  {      xQueueHandle xQueue;     /*创建一个队列，可以容纳10个char类型数值 */     xQueue = xQueueCreate( 10, sizeof( portCHAR ) );     /* 我们想可视化调试，所以注册它*/     vQueueAddToRegistry( xQueue, "AMeaningfulName" );  }</pre> </div> <p class="maodian"><a name="_label17" rel="nofollow"></a></p> <h2>17.解除注册</h2> <p class="maodian"><a name="_lab2_17_53" rel="nofollow"></a></p> <h3>17.1函数描述</h3> <blockquote> <p>void vQueueUnregisterQueue(QueueHandle_t xQueue);</p> </blockquote> <p>从队列注册表中移除指定的队列。</p> <p class="maodian"><a name="_lab2_17_54" rel="nofollow"></a></p> <h3>17.2参数描述</h3> <p>xQueue：队列句柄</p> <p class="maodian"><a name="_label18" rel="nofollow"></a></p> <h2>18.查询队列是否为空（仅用于中断服务程序）</h2> <p class="maodian"><a name="_lab2_18_55" rel="nofollow"></a></p> <h3>18.1函数描述</h3> <blockquote> <p>BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue );</p> </blockquote> <p>查询队列是否为空。这个函数仅用于ISR。</p> <p class="maodian"><a name="_lab2_18_56" rel="nofollow"></a></p> <h3>18.2参数描述</h3> <p>xQueue：队列句柄</p> <p class="maodian"><a name="_lab2_18_57" rel="nofollow"></a></p> <h3>18.3返回值</h3> <p>队列非空返回pdFALSE，其它值表示队列为空。</p> <p class="maodian"><a name="_label19" rel="nofollow"></a></p> <h2>19.查询队列是否满（仅用于中断服务程序）</h2> <p class="maodian"><a name="_lab2_19_58" rel="nofollow"></a></p> <h3>19.1函数描述</h3> <blockquote> <p>BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue );</p> </blockquote> <p>查询队列是否满，仅用于ISR。</p> <p class="maodian"><a name="_lab2_19_59" rel="nofollow"></a></p> <h3>19.2参数描述</h3> <p>xQueue：队列句柄</p> <p class="maodian"><a name="_lab2_19_60" rel="nofollow"></a></p> <h3>19.3返回值</h3> <p>队列没有满返回pdFALSE，其它值表示队列满。</p> <p class="maodian"><a name="_label20" rel="nofollow"></a></p> <h2>20.向队列尾部覆盖式投递队列项</h2> <p class="maodian"><a name="_lab2_20_61" rel="nofollow"></a></p> <h3>20.1函数描述</h3> <blockquote> <p>BaseType_t xQueueOverwrite(QueueHandle_t xQueue, const void * pvItemToQueue);</p> </blockquote> <p>其实是个宏，真正被调用的函数是xQueueGenericSend()。这个宏是xQueueSendToBack()的另一个版本，向队列尾投递一个队列项，如果队列已满，则覆盖之前的队列项。一般用于只有一个队列项的队列中，如果队列的队列项超过1个，使用这个宏会触发一个断言（已经正确定义configASSERT()的情况下）。这个宏绝不可以在中断服务程序中调用，可以使用使用带有中断保护的版本xQueueOverwriteFromISR()来完成相同功能。</p> <p class="maodian"><a name="_lab2_20_62" rel="nofollow"></a></p> <h3>20.2参数描述</h3> <p>xQueue：队列句柄。</p> <p>pvItemToQueue：指针，指向要入队的项目。要保存到队列中的项目字节数在队列创建时就已确定。因此要从指针pvItemToQueue指向的区域拷贝到队列存储区域的字节数，也已确定。</p> <p class="maodian"><a name="_lab2_20_63" rel="nofollow"></a></p> <h3>20.3返回值</h3> <p>总是返回pdPASS。</p> <p class="maodian"><a name="_lab2_20_64" rel="nofollow"></a></p> <h3>20.4用法举例</h3> <div class="ay1code"> <pre class="brush:cpp;">void vFunction( void *pvParameters )  {      QueueHandle_t xQueue;      unsigned long ulVarToSend, ulValReceived;      /*创建队列，保存一个unsignedlong值。如果一个队列的队列项超过1个，强烈建议不要使用xQueueOverwrite()，如果使用xQueueOverwrite()会触发一个断言（已经正确定义configASSERT()的情况下）。*/      xQueue = xQueueCreate( 1, sizeof( unsigned long ) );       /*使用 xQueueOverwrite().向队列写入10*/      ulVarToSend = 10;      xQueueOverwrite( xQueue, &amp;ulVarToSend );      /*从队列读取值，但是不把这个值从队列中删除。*/      ulValReceived = 0;      xQueuePeek( xQueue, &amp;ulValReceived, 0 );      if( ulValReceived != 10 )       {            /* 处理错误*/       }       /*到这里队列仍是满的。使用xQueueOverwrite()覆写队列，写入值100 */       ulVarToSend = 100;       xQueueOverwrite( xQueue, &amp;ulVarToSend );       /* 从队列中读取值*/       xQueueReceive( xQueue, &amp;ulValReceived, 0 );       if( ulValReceived != 100 )       {            /*处理错误 */       }        /* ... */  }</pre> </div> <p class="maodian"><a name="_label21" rel="nofollow"></a></p> <h2>21向队列尾部覆盖式投递队列项（带中断保护）</h2> <p class="maodian"><a name="_lab2_21_65" rel="nofollow"></a></p> <h3>21.1函数描述</h3> <div class="ay1code"> <pre class="brush:cpp;">      BaseType_t xQueueOverwriteFromISR (QueueHandle_t xQueue, const void * pvItemToQueue,                               BaseType_t *pxHigherPriorityTaskWoken);</pre> </div> <p>其实是个宏，真正被调用的函数是xQueueGenericSendFromISR()。这个宏的功能与xQueueOverwrite()相同，用在中断服务程序中。</p> <p class="maodian"><a name="_lab2_21_66" rel="nofollow"></a></p> <h3>21.2参数描述</h3> <p><code>xQueue</code>：队列句柄。</p> <p><code>pvItemToQueue</code>：指针，指向要入队的项目。要保存到队列中的项目字节数在队列创建时就已确定。因此要从指针pvItemToQueue指向的区域拷贝到队列存储区域的字节数，也已确定。</p> <p><code>pxHigherPriorityTaskWoken</code>：如果入队导致一个任务解锁，并且解锁的任务优先级高于当前运行的任务，则该函数将*pxHigherPriorityTaskWoken设置成pdTRUE。如果xQueueSendFromISR()设置这个值为pdTRUE，则中断退出前需要一次上下文切换。从FreeRTOS V7.3.0起，pxHigherPriorityTaskWoken称为一个可选参数，并可以设置为NULL。</p> <p class="maodian"><a name="_lab2_21_67" rel="nofollow"></a></p> <h3>21.3返回值</h3> <p>总是返回pdPASS。</p> 			                <div class="clearfix"></div>
                <div class="col-md-12 mt-5">
                                        <p>上一个：<a href="/news/article-20275.htm">动物疫苗赚钱吗知乎（做动物疫苗前景）</a></p>
                                        <p>下一个：<a href="/news/article-20729.htm">基于vue-seamless-scroll实现无缝滚动效果_vue.js</a></p>
                                    </div>
                                </div>
                <div class="col-md-3">
                    <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">热门文章</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2"><a href="/free-nodes/2024-8-28-clash-windows.htm" title="「8月28日」最高速度22.7M/S，2024年Clash/Shadowrocket/V2ray/SSR每天更新免费机场订阅链接">「8月28日」最高速度22.7M/S，2024年Clash/Shadowrocket/V2ray/SSR每天更新免费机场订阅链接</a></li>
                        <li class="py-2"><a href="/news/article-19816.htm" title=".NET混合开发解决方案4 WebView2的线程模型">.NET混合开发解决方案4 WebView2的线程模型</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-11-15-free-v2ray-subscribe.htm" title="「11月15日」最高速度18M/S，2024年V2ray/Shadowrocket/SSR/Clash每天更新免费机场订阅链接">「11月15日」最高速度18M/S，2024年V2ray/Shadowrocket/SSR/Clash每天更新免费机场订阅链接</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-10-18-free-node-subscribe.htm" title="「10月18日」最高速度20.4M/S，2024年Clash/SSR/V2ray/Shadowrocket每天更新免费机场订阅链接">「10月18日」最高速度20.4M/S，2024年Clash/SSR/V2ray/Shadowrocket每天更新免费机场订阅链接</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-12-4-free-node-subscribe.htm" title="「12月4日」最高速度19M/S，2024年Shadowrocket/V2ray/Clash/SSR每天更新免费机场订阅链接">「12月4日」最高速度19M/S，2024年Shadowrocket/V2ray/Clash/SSR每天更新免费机场订阅链接</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-11-23-free-high-speed-nodes.htm" title="「11月23日」最高速度18M/S，2024年V2ray/Shadowrocket/SSR/Clash每天更新免费机场订阅链接">「11月23日」最高速度18M/S，2024年V2ray/Shadowrocket/SSR/Clash每天更新免费机场订阅链接</a></li>
                        <li class="py-2"><a href="/news/article-21636.htm" title="养猫的人容易得什么病猫藓（养猫的人容易得什么皮肤病）">养猫的人容易得什么病猫藓（养猫的人容易得什么皮肤病）</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-9-16-node-share-links.htm" title="「9月16日」最高速度19.4M/S，2024年Clash/Shadowrocket/SSR/V2ray每天更新免费机场订阅链接">「9月16日」最高速度19.4M/S，2024年Clash/Shadowrocket/SSR/V2ray每天更新免费机场订阅链接</a></li>
                        <li class="py-2"><a href="/news/article-20729.htm" title="基于vue-seamless-scroll实现无缝滚动效果_vue.js">基于vue-seamless-scroll实现无缝滚动效果_vue.js</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-10-2-free-shadowrocket-node.htm" title="「10月2日」最高速度21.7M/S，2024年Shadowrocket/V2ray/SSR/Clash每天更新免费机场订阅链接">「10月2日」最高速度21.7M/S，2024年Shadowrocket/V2ray/SSR/Clash每天更新免费机场订阅链接</a></li>
                    </ul>
    </div>
</div>

<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">归纳</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">15</span> <a href="/date/2024-12/" title="2024-12 归档">2024-12</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">34</span> <a href="/date/2024-11/" title="2024-11 归档">2024-11</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">31</span> <a href="/date/2024-10/" title="2024-10 归档">2024-10</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">30</span> <a href="/date/2024-09/" title="2024-09 归档">2024-09</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">31</span> <a href="/date/2024-08/" title="2024-08 归档">2024-08</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">27</span> <a href="/date/2024-07/" title="2024-07 归档">2024-07</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">16</span> <a href="/date/2024-06/" title="2024-06 归档">2024-06</a></h4>
            </li>
                    </ul>
    </div>
</div>



                </div>
            </div>
        </div>
    </section>
        <footer class="main-footer">
        <div class="copyrights">
            <div class="container">
                <div class="row">
                    <div class="col-lg-6 text-center text-lg-left">
                        <p class="copyrights-text mb-3 mb-lg-0">
                          TodayClashNode今日订阅站 版权所有 Powered by WordPress
                        </p>
                    </div>
                    <div class="col-lg-6 text-center text-lg-right">
                        <ul class="list-inline social mb-0">
                            <li class="list-inline-item"><a href="#" class="social-link"><i class="fa fa-facebook"></i></a><a href="#" class="social-link"><i class="fa fa-twitter"></i></a><a href="#" class="social-link"><i class="fa fa-youtube-play"></i></a><a href="#" class="social-link"><i class="fa fa-vimeo"></i></a><a href="#" class="social-link"><i class="fa fa-pinterest"></i></a></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </footer>
    <!-- JavaScript files-->
    <script src="/assets/website/js/frontend/todayclashnode/jquery/jquery.min.js"></script>
    <script src="/assets/website/js/frontend/todayclashnode/bootstrap/js/bootstrap.bundle.min.js"></script>
    <script src="/assets/website/js/frontend/todayclashnode/jquery.cookie/jquery.cookie.js"> </script>
    <script src="/assets/website/js/frontend/todayclashnode/lightbox2/js/lightbox.js"></script>
    <script src="/assets/website/js/frontend/todayclashnode/front.js"></script>
    <script src="https://www.freeclashnode.com/assets/js/frontend/invite-url.js"></script>
    <script src="/assets/website/js/frontend/G.js"></script>
</body>

</html>